<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ParallelUtilities.jl</title><link rel="canonical" href="https://jishnub.github.io/ParallelUtilities.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ParallelUtilities.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jishnub/ParallelUtilities.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ParallelUtilities.jl"><a class="docs-heading-anchor" href="#ParallelUtilities.jl">ParallelUtilities.jl</a><a id="ParallelUtilities.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ParallelUtilities.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.AbstractConstrainedProduct" href="#ParallelUtilities.AbstractConstrainedProduct"><code>ParallelUtilities.AbstractConstrainedProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractConstrainedProduct{T,N}</code></pre><p>Supertype of <a href="#ParallelUtilities.ProductSplit"><code>ProductSplit</code></a> and <a href="#ParallelUtilities.ProductSection"><code>ProductSection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.ProductSection" href="#ParallelUtilities.ProductSection"><code>ParallelUtilities.ProductSection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProductSection{T,N,Q}</code></pre><p>Iterator that loops over a specified section of the  outer product of the ranges provided in  reverse-lexicographic order. The ranges need to be strictly increasing. Given <code>N</code> ranges,  each element returned by the iterator will be  a tuple of length <code>N</code> with one element from each range.</p><p>See also: <a href="#ParallelUtilities.ProductSplit"><code>ProductSplit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.ProductSection-Tuple{Tuple{AbstractRange,Vararg{AbstractRange,N} where N},AbstractUnitRange}" href="#ParallelUtilities.ProductSection-Tuple{Tuple{AbstractRange,Vararg{AbstractRange,N} where N},AbstractUnitRange}"><code>ParallelUtilities.ProductSection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ProductSection(iterators::Tuple{Vararg{AbstractRange}}, inds::AbstractUnitRange)</code></pre><p>Construct a <code>ProductSection</code> iterator that represents a 1D view of the outer product of the ranges provided in <code>iterators</code>, with the range of indices in the view being specified by <code>inds</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; p = ParallelUtilities.ProductSection((1:3,4:6), 5:8);

julia&gt; collect(p)
4-element Array{Tuple{Int64,Int64},1}:
 (2, 5)
 (3, 5)
 (1, 6)
 (2, 6)

julia&gt; collect(p) == collect(Iterators.product(1:3, 4:6))[5:8]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL50-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.ProductSplit" href="#ParallelUtilities.ProductSplit"><code>ParallelUtilities.ProductSplit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProductSplit{T,N,Q}</code></pre><p>Iterator that loops over the outer product of ranges in  reverse-lexicographic order. The ranges need to be strictly increasing. Given <code>N</code> ranges,  each element returned by the iterator will be  a tuple of length <code>N</code> with one element from each range.</p><p>See also: <a href="#ParallelUtilities.ProductSection"><code>ProductSection</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL88-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.ProductSplit-Tuple{Tuple{AbstractRange,Vararg{AbstractRange,N} where N},Integer,Integer}" href="#ParallelUtilities.ProductSplit-Tuple{Tuple{AbstractRange,Vararg{AbstractRange,N} where N},Integer,Integer}"><code>ParallelUtilities.ProductSplit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ProductSplit(iterators::Tuple{Vararg{AbstractRange}}, np::Integer, p::Integer)</code></pre><p>Construct a <code>ProductSplit</code> iterator that represents the outer product  of the iterators split over <code>np</code> workers, with this instance reprsenting  the values on the <code>p</code>-th worker.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ProductSplit((1:2,4:5), 2, 1) |&gt; collect
2-element Array{Tuple{Int64,Int64},1}:
 (1, 4)
 (2, 4)

julia&gt; ProductSplit((1:2,4:5), 2, 2) |&gt; collect
2-element Array{Tuple{Int64,Int64},1}:
 (1, 5)
 (2, 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL110-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.extrema-Tuple{ParallelUtilities.AbstractConstrainedProduct}" href="#Base.extrema-Tuple{ParallelUtilities.AbstractConstrainedProduct}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extrema(ps::AbstractConstrainedProduct; dim::Integer)</code></pre><p>Compute the <code>extrema</code> of the section of the range number <code>dim</code> contained in <code>ps</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ps = ProductSplit((1:2, 4:5), 2, 1);

julia&gt; collect(ps)
2-element Array{Tuple{Int64,Int64},1}:
 (1, 4)
 (2, 4)

julia&gt; extrema(ps, dim = 1)
(1, 2)

julia&gt; extrema(ps, dim = 2)
(4, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL535-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maximum-Tuple{ParallelUtilities.AbstractConstrainedProduct}" href="#Base.maximum-Tuple{ParallelUtilities.AbstractConstrainedProduct}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">maximum(ps::AbstractConstrainedProduct; dim::Integer)</code></pre><p>Compute the maximum value of the section of the range number <code>dim</code> contained in <code>ps</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ps = ProductSplit((1:2,4:5),2,1);

julia&gt; collect(ps)
2-element Array{Tuple{Int64,Int64},1}:
 (1, 4)
 (2, 4)

julia&gt; maximum(ps, dim = 1)
2

julia&gt; maximum(ps, dim = 2)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL419-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.minimum-Tuple{ParallelUtilities.AbstractConstrainedProduct}" href="#Base.minimum-Tuple{ParallelUtilities.AbstractConstrainedProduct}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimum(ps::AbstractConstrainedProduct; dim::Integer)</code></pre><p>Compute the minimum value of the section of the range number <code>dim</code> contained in <code>ps</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ps = ProductSplit((1:2, 4:5), 2, 1);

julia&gt; collect(ps)
2-element Array{Tuple{Int64,Int64},1}:
 (1, 4)
 (2, 4)

julia&gt; minimum(ps, dim = 1)
1

julia&gt; minimum(ps, dim = 2)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL477-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.childindex-Tuple{ParallelUtilities.AbstractConstrainedProduct,Any}" href="#ParallelUtilities.childindex-Tuple{ParallelUtilities.AbstractConstrainedProduct,Any}"><code>ParallelUtilities.childindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">childindex(ps::AbstractConstrainedProduct, ind)</code></pre><p>Return a tuple containing the indices of the individual <code>AbstractRange</code>s corresponding to the element that is present at index <code>ind</code> in the  outer product of the ranges.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The index <code>ind</code> corresponds to the outer product of the ranges, and not to <code>ps</code>. </p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; iters = (1:5, 2:4, 1:3);

julia&gt; ps = ProductSplit(iters, 7, 1);

julia&gt; ind = 6;

julia&gt; cinds = ParallelUtilities.childindex(ps, ind)
(1, 2, 1)

julia&gt; v = collect(Iterators.product(iters...));

julia&gt; getindex.(iters, cinds) == v[ind]
true</code></pre><p>See also: <a href="#ParallelUtilities.childindexshifted-Tuple{ParallelUtilities.AbstractConstrainedProduct,Any}"><code>childindexshifted</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL203-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.childindexshifted-Tuple{ParallelUtilities.AbstractConstrainedProduct,Any}" href="#ParallelUtilities.childindexshifted-Tuple{ParallelUtilities.AbstractConstrainedProduct,Any}"><code>ParallelUtilities.childindexshifted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">childindexshifted(ps::AbstractConstrainedProduct, ind)</code></pre><p>Return a tuple containing the indices in the individual iterators  given an index of a <code>AbstractConstrainedProduct</code>.</p><p>If the ranges <code>(r1, r2, ...)</code> are used to generate <code>ps</code>, then return <code>(i1, i2, ...)</code> such that <code>ps[ind] == (r1[i1], r2[i2], ...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; iters = (1:5, 2:4, 1:3);

julia&gt; ps = ProductSplit(iters, 7, 3);

julia&gt; psind = 4;

julia&gt; cinds = ParallelUtilities.childindexshifted(ps, psind)
(3, 1, 2)

julia&gt; getindex.(iters, cinds) == ps[psind]
true</code></pre><p>See also: <a href="#ParallelUtilities.childindex-Tuple{ParallelUtilities.AbstractConstrainedProduct,Any}"><code>childindex</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL246-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.dropleading-Tuple{ParallelUtilities.AbstractConstrainedProduct}" href="#ParallelUtilities.dropleading-Tuple{ParallelUtilities.AbstractConstrainedProduct}"><code>ParallelUtilities.dropleading</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dropleading(ps::AbstractConstrainedProduct)</code></pre><p>Return a <code>ProductSection</code> leaving out the first iterator contained in <code>ps</code>.  The range of values of the remaining iterators in the  resulting <code>ProductSection</code> will be the same as in <code>ps</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ps = ProductSplit((1:5, 2:4, 1:3), 7, 3);

julia&gt; collect(ps)
7-element Array{Tuple{Int64,Int64,Int64},1}:
 (5, 4, 1)
 (1, 2, 2)
 (2, 2, 2)
 (3, 2, 2)
 (4, 2, 2)
 (5, 2, 2)
 (1, 3, 2)

julia&gt; ParallelUtilities.dropleading(ps) |&gt; collect
3-element Array{Tuple{Int64,Int64},1}:
 (4, 1)
 (2, 2)
 (3, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL958-L985">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.extrema_commonlastdim-Union{Tuple{ParallelUtilities.AbstractConstrainedProduct{var&quot;#s25&quot;,N} where var&quot;#s25&quot;}, Tuple{N}} where N" href="#ParallelUtilities.extrema_commonlastdim-Union{Tuple{ParallelUtilities.AbstractConstrainedProduct{var&quot;#s25&quot;,N} where var&quot;#s25&quot;}, Tuple{N}} where N"><code>ParallelUtilities.extrema_commonlastdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extrema_commonlastdim(ps::AbstractConstrainedProduct)</code></pre><p>Return the reverse-lexicographic extrema of values taken from  ranges contained in <code>ps</code>, where the pairs of ranges are constructed  by concatenating the ranges along each dimension with the last one.</p><p>For two ranges this simply returns <code>([first(ps)], [last(ps)])</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ps = ProductSplit((1:3,4:7,2:7), 10, 2);

julia&gt; collect(ps)
8-element Array{Tuple{Int64,Int64,Int64},1}:
 (3, 6, 2)
 (1, 7, 2)
 (2, 7, 2)
 (3, 7, 2)
 (1, 4, 3)
 (2, 4, 3)
 (3, 4, 3)
 (1, 5, 3)

julia&gt; extrema_commonlastdim(ps)
([(1, 2), (6, 2)], [(3, 3), (5, 3)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL634-L661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.extremadims-Tuple{ParallelUtilities.AbstractConstrainedProduct}" href="#ParallelUtilities.extremadims-Tuple{ParallelUtilities.AbstractConstrainedProduct}"><code>ParallelUtilities.extremadims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extremadims(ps::AbstractConstrainedProduct)</code></pre><p>Compute the extrema of the sections of all the ranges contained in <code>ps</code>.  Functionally this is equivalent to </p><pre><code class="language-julia">map(i -&gt; extrema(ps, dim = i), 1:ndims(ps))</code></pre><p>but it is implemented more efficiently. </p><p>Returns a <code>Tuple</code> containing the <code>(min,max)</code> pairs along each  dimension, such that the <code>i</code>-th index of the result contains the <code>extrema</code> along the section of the <code>i</code>-th range contained locally.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ps = ProductSplit((1:2, 4:5), 2, 1);

julia&gt; collect(ps)
2-element Array{Tuple{Int64,Int64},1}:
 (1, 4)
 (2, 4)

julia&gt; extremadims(ps)
((1, 2), (4, 4))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL595-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.indexinproduct-Union{Tuple{N}, Tuple{Tuple{Vararg{AbstractRange,N}},Tuple{Vararg{Any,N}}}} where N" href="#ParallelUtilities.indexinproduct-Union{Tuple{N}, Tuple{Tuple{Vararg{AbstractRange,N}},Tuple{Vararg{Any,N}}}} where N"><code>ParallelUtilities.indexinproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">indexinproduct(iterators::NTuple{N,AbstractRange}, val::NTuple{N,Any}) where {N}</code></pre><p>Return the index of <code>val</code> in the outer product of <code>iterators</code>,  where <code>iterators</code> is a <code>Tuple</code> of increasing <code>AbstractRange</code>s.  Return nothing if <code>val</code> is not present.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; iterators = (1:4, 1:3, 3:5);

julia&gt; val = (2, 2, 4);

julia&gt; ind = ParallelUtilities.indexinproduct(iterators,val)
18

julia&gt; collect(Iterators.product(iterators...))[ind] == val
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL713-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.localindex-Union{Tuple{T}, Tuple{ParallelUtilities.AbstractConstrainedProduct{T,N} where N,T}} where T" href="#ParallelUtilities.localindex-Union{Tuple{T}, Tuple{ParallelUtilities.AbstractConstrainedProduct{T,N} where N,T}} where T"><code>ParallelUtilities.localindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">localindex(ps::AbstractConstrainedProduct{T}, val::T) where {T}</code></pre><p>Return the index of <code>val</code> in <code>ps</code>. Return <code>nothing</code> if the value is not found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ps = ProductSplit((1:3, 4:5:20), 3, 2);

julia&gt; collect(ps)
4-element Array{Tuple{Int64,Int64},1}:
 (2, 9)
 (3, 9)
 (1, 14)
 (2, 14)

julia&gt; localindex(ps, (3,9))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL889-L909">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.nelements-Tuple{ParallelUtilities.AbstractConstrainedProduct,Integer}" href="#ParallelUtilities.nelements-Tuple{ParallelUtilities.AbstractConstrainedProduct,Integer}"><code>ParallelUtilities.nelements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nelements(ps::AbstractConstrainedProduct; dim::Integer)</code></pre><p>Compute the number of unique values in the section of the <code>dim</code>-th range contained in <code>ps</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ps = ProductSplit((1:5, 2:4, 1:3), 7, 3);

julia&gt; collect(ps)
7-element Array{Tuple{Int64,Int64,Int64},1}:
 (5, 4, 1)
 (1, 2, 2)
 (2, 2, 2)
 (3, 2, 2)
 (4, 2, 2)
 (5, 2, 2)
 (1, 3, 2)

julia&gt; ParallelUtilities.nelements(ps, dim = 1)
5

julia&gt; ParallelUtilities.nelements(ps, dim = 2)
3

julia&gt; ParallelUtilities.nelements(ps, dim = 3)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL357-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.ntasks" href="#ParallelUtilities.ntasks"><code>ParallelUtilities.ntasks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ntasks(iterators::Tuple)</code></pre><p>The total number of elements in the outer product of the ranges contained in  <code>iterators</code>, equal to <code>prod(length, iterators)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.nworkersactive-Tuple{Tuple}" href="#ParallelUtilities.nworkersactive-Tuple{Tuple}"><code>ParallelUtilities.nworkersactive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nworkersactive(iterators::Tuple)</code></pre><p>Number of workers required to contain the outer product of the iterators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/utils.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.pmapbatch-Tuple{Function,Tuple,Vararg{Any,N} where N}" href="#ParallelUtilities.pmapbatch-Tuple{Function,Tuple,Vararg{Any,N} where N}"><code>ParallelUtilities.pmapbatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pmapbatch(f, iterators, [mapargs...]; 
    [num_workers::Int = nworkersactive(iterators)], [mapkwargs...])</code></pre><p>Evaluate the function <code>f</code> in parallel, where each worker gets a  part of the entire parameter space sequentially. The argument  <code>iterators</code> needs to be a strictly-increasing range, or a tuple of such ranges. The outer product of these ranges forms the  entire range of parameters that is processed in batches on  the workers. Arguments <code>mapargs</code> and keyword arguments <code>mapkwargs</code> — if provided — are  passed on to the function <code>f</code>. </p><p>Additionally, the number of workers to be used may be specified using the  keyword argument <code>num_workers</code>. In this case the first <code>num_workers</code> available workers are used in the evaluation.</p><pre><code class="language-none">pmapbatch(f, T::Type, iterators, [mapargs...];
    [num_workers::Int = nworkersactive(iterators)], [mapkwargs...])</code></pre><p>Evaluate <code>f</code> in parallel, and convert the returned value to type <code>T</code>.  The method is type stable if <code>T</code> is concrete. Values returned by <code>f</code> will be type-coerced if possible, and an error will be raised otherwise.</p><p>See also: <a href="#ParallelUtilities.pmapreduce-Tuple{Function,Type,Function,Type,Tuple,Vararg{Any,N} where N}"><code>pmapreduce</code></a>, <a href="#ParallelUtilities.pmapsum-Tuple{Function,Type,Any,Vararg{Any,N} where N}"><code>pmapsum</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/mapreduce.jl#LL573-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.pmapbatch_elementwise-Tuple{Function,Any,Vararg{Any,N} where N}" href="#ParallelUtilities.pmapbatch_elementwise-Tuple{Function,Any,Vararg{Any,N} where N}"><code>ParallelUtilities.pmapbatch_elementwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pmapbatch_elementwise(f, iterators, [mapargs...]; 
    [num_workers::Int = nworkersactive(iterators)], [mapkwargs...])</code></pre><p>Evaluate the function <code>f</code> in parallel, where each worker gets a  part of the entire parameter space sequentially. The argument  <code>iterators</code> needs to be a strictly-increasing range of intergers, or a tuple of such ranges. The outer product of these ranges forms the  entire range of parameters that is processed elementwise by the function <code>f</code>. The individual tuples are splatted and passed as arguments to <code>f</code>. Given <code>n</code> ranges in <code>iterators</code>, the function <code>f</code> will receive <code>n</code> values  at a time.</p><p>Arguments <code>mapargs</code> and keyword arguments <code>mapkwargs</code> — if provided — are  passed on to the function <code>f</code>.  Additionally, the number of workers to be used may be specified using the  keyword argument <code>num_workers</code>. In this case the first <code>num_workers</code> available workers are used in the evaluation.</p><p>See also: <a href="#ParallelUtilities.pmapbatch-Tuple{Function,Tuple,Vararg{Any,N} where N}"><code>pmapbatch</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/mapreduce.jl#LL633-L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.pmapreduce-Tuple{Function,Type,Function,Type,Tuple,Vararg{Any,N} where N}" href="#ParallelUtilities.pmapreduce-Tuple{Function,Type,Function,Type,Tuple,Vararg{Any,N} where N}"><code>ParallelUtilities.pmapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pmapreduce(fmap, freduce, iterators, [mapargs...]; 
    &lt;keyword arguments&gt;, [mapkwargs...])</code></pre><p>Evaluate a parallel mapreduce over the range spanned by  the outer product of the iterators.</p><p><code>iterators</code> must be a strictly-increasing range of integers,  or a tuple of such ranges.  The outer product of the ranges is split evenly across the workers.  The function <code>fmap</code> receives a <code>ProductSplit</code> iterator as its first argument that acts as a collection of tuples. One may index into a <code>ProductSplit</code>  or iterate over one to access individual tuples of integers.</p><p>The reduction function <code>freduce</code> is expected to accept a collection of mapped values. Note that this is different from the standard <code>mapreduce</code> operation in julia that  expects a binary reduction operator. For example, <code>fmap</code> should be  <code>sum</code> and not <code>+</code>. In case a binary operator <code>op</code> is to be used in the reduction, one may pass it  as <code>Base.splat(op)</code> or wrap it in an anonymous function as <code>x -&gt; op(x...)</code>.</p><p>Arguments <code>mapargs</code> and keyword arguments <code>mapkwargs</code> — if provided — are  passed on to the mapping function <code>fmap</code>.</p><pre><code class="language-none">pmapreduce(fmap, Tmap, freduce, Treduce, iterators, [mapargs...]; 
    &lt;keyword arguments&gt;, [mapkwargs...])</code></pre><p>The types <code>Tmap</code> and <code>Treduce</code> are the return types of the map and  reduce operations respectively. The returned values will be coerced to  the specified types if possible, throwing an error otherwise. </p><p><strong>Keyword Arguments</strong></p><ul><li><code>showprogress::Bool = false</code> : Displays a progress-bar if set to true</li><li><code>progressdesc = &quot;Progress in pmapreduce : &quot;</code> : Leading text in the progress-bar</li></ul><p>See also: <a href="#ParallelUtilities.pmapreduce_commutative-Tuple{Function,Type,Function,Type,Tuple,Vararg{Any,N} where N}"><code>pmapreduce_commutative</code></a>, <a href="#ParallelUtilities.pmapsum-Tuple{Function,Type,Any,Vararg{Any,N} where N}"><code>pmapsum</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/mapreduce.jl#LL506-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.pmapreduce_commutative-Tuple{Function,Type,Function,Type,Tuple,Vararg{Any,N} where N}" href="#ParallelUtilities.pmapreduce_commutative-Tuple{Function,Type,Function,Type,Tuple,Vararg{Any,N} where N}"><code>ParallelUtilities.pmapreduce_commutative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pmapreduce_commutative(fmap, freduce, iterators, [mapargs...]; 
    &lt;keyword arguments&gt;, [mapkwargs...])</code></pre><p>Evaluate a parallel mapreduce over the range spanned by  the outer product of the iterators. The operation is assumed to be commutative, results obtained may be incorrect otherwise.</p><p>The argument  <code>iterators</code> must be a strictly-increasing range of integers,  or a tuple of such ranges.  The outer product of the ranges is split evenly across the workers.  The function <code>fmap</code> receives a <code>ProductSplit</code> iterator as its first argument that acts as a collection of tuples. One may index into a <code>ProductSplit</code>  or iterate over one to access individual tuples of integers.</p><p>The reduction function <code>freduce</code> is expected to accept a collection of mapped values. Note that this is different from the standard <code>mapreduce</code> operation in julia that  expects a binary reduction operator. For example, <code>freduce</code> should be  <code>sum</code> and not <code>+</code>. In case a binary operator <code>op</code> is to be used in the reduction, one may pass it  as <code>Base.splat(op)</code> or wrap it in an anonymous function as <code>x -&gt; op(x...)</code>.</p><p>Arguments <code>mapargs</code> and keyword arguments <code>mapkwargs</code> — if provided — are  passed on to the mapping function <code>fmap</code>.</p><pre><code class="language-none">pmapreduce_commutative(fmap, Tmap, freduce, Treduce, iterators, [mapargs...]; 
    &lt;keyword arguments&gt;, [mapkwargs...])</code></pre><p>The types <code>Tmap</code> and <code>Treduce</code> are the return types of the map and  reduce operations respectively. The returned values will be coerced to  the specified types if possible, throwing an error otherwise. </p><p><strong>Keyword Arguments</strong></p><ul><li><code>showprogress::Bool = false</code> : Displays a progress-bar if set to true</li><li><code>progressdesc = &quot;Progress in pmapreduce : &quot;</code> : Leading text in the progress-bar</li></ul><p>See also: <a href="#ParallelUtilities.pmapreduce_commutative_elementwise-Tuple{Function,Type,Function,Type,Any,Vararg{Any,N} where N}"><code>pmapreduce_commutative_elementwise</code></a>, <a href="#ParallelUtilities.pmapreduce-Tuple{Function,Type,Function,Type,Tuple,Vararg{Any,N} where N}"><code>pmapreduce</code></a>, <a href="#ParallelUtilities.pmapsum-Tuple{Function,Type,Any,Vararg{Any,N} where N}"><code>pmapsum</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/mapreduce.jl#LL300-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.pmapreduce_commutative_elementwise-Tuple{Function,Type,Function,Type,Any,Vararg{Any,N} where N}" href="#ParallelUtilities.pmapreduce_commutative_elementwise-Tuple{Function,Type,Function,Type,Any,Vararg{Any,N} where N}"><code>ParallelUtilities.pmapreduce_commutative_elementwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pmapreduce_commutative_elementwise(fmap, freduce, iterators, [mapargs...]; 
    &lt;keyword arguments&gt;, [mapkwargs...])</code></pre><p>Evaluate a parallel mapreduce over the range spanned by  the outer product of the iterators.  The argument <code>iterators</code> must be a strictly-increasing range of integers,  or a tuple of such ranges. The map is evaluated elementwise  over the entire range of parameters. The reduction is assumed to be commutative,  results obtained may be incorrect otherwise.</p><p>The reduction function <code>freduce</code> is expected to accept a collection of mapped values. Note that this is different from the standard <code>mapreduce</code> operation in julia that  expects a binary reduction operator. For example, <code>freduce</code> should be  <code>sum</code> and not <code>+</code>. In case a binary operator <code>op</code> is to be used in the reduction, one may pass it  as <code>Base.splat(op)</code> or wrap it in an anonymous function as <code>x -&gt; op(x...)</code>.</p><p>Arguments <code>mapargs</code> and keyword arguments <code>mapkwargs</code> — if provided — are  passed on to the mapping function <code>fmap</code>.</p><pre><code class="language-none">pmapreduce_commutative_elementwise(fmap, Tmap, freduce, Treduce, iterators, [mapargs...]; 
    &lt;keyword arguments&gt;, [mapkwargs...])</code></pre><p>The types <code>Tmap</code> and <code>Treduce</code> are the return types of the map and  reduce operations respectively. The returned values will be coerced to  the specified types if possible, throwing an error otherwise. </p><p><strong>Keyword Arguments</strong></p><ul><li><code>showprogress::Bool = false</code> : Displays a progress-bar if set to true</li><li><code>progressdesc = &quot;Progress in pmapreduce : &quot;</code> : Leading text in the progress-bar</li></ul><p>See also: <a href="#ParallelUtilities.pmapreduce_commutative-Tuple{Function,Type,Function,Type,Tuple,Vararg{Any,N} where N}"><code>pmapreduce_commutative</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/mapreduce.jl#LL365-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.pmapsum-Tuple{Function,Type,Any,Vararg{Any,N} where N}" href="#ParallelUtilities.pmapsum-Tuple{Function,Type,Any,Vararg{Any,N} where N}"><code>ParallelUtilities.pmapsum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pmapsum(fmap, iterators, [mapargs...]; 
    &lt;keyword arguments&gt;, [mapkwargs...])</code></pre><p>Evaluate a parallel mapreduce over the range spanned by  the outer product of the iterators, where the reduction operation is a sum.</p><p>The argument <code>iterators</code> must be a strictly-increasing range of integers,  or a tuple of such ranges. The outer product of the ranges is split evenly across the workers.  The function <code>fmap</code> receives a <code>ProductSplit</code> iterator as its first argument that acts as a collection of tuples. One may index into a <code>ProductSplit</code>  or iterate over one to access individual tuples of integers.</p><p>Arguments <code>mapargs</code> and keyword arguments <code>mapkwargs</code> — if provided — are  passed on to the mapping function <code>fmap</code>.</p><pre><code class="language-none">pmapsum(fmap, Tmap, iterators, [mapargs...]; 
    &lt;keyword arguments&gt;, [mapkwargs...])</code></pre><p>The types <code>Tmap</code> is the return types of the map.  The returned values will be coerced to  the specified type if possible, throwing an error otherwise.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>showprogress::Bool = false</code> : Displays a progress-bar if set to true</li><li><code>progressdesc = &quot;Progress in pmapsum : &quot;</code> : Leading text in the progress-bar</li></ul><p>See also: <a href="#ParallelUtilities.pmapreduce-Tuple{Function,Type,Function,Type,Tuple,Vararg{Any,N} where N}"><code>pmapreduce</code></a>, <a href="#ParallelUtilities.pmapreduce_commutative-Tuple{Function,Type,Function,Type,Tuple,Vararg{Any,N} where N}"><code>pmapreduce_commutative</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/mapreduce.jl#LL421-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.pmapsum_elementwise-Tuple{Function,Type,Any,Vararg{Any,N} where N}" href="#ParallelUtilities.pmapsum_elementwise-Tuple{Function,Type,Any,Vararg{Any,N} where N}"><code>ParallelUtilities.pmapsum_elementwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pmapsum_elementwise(fmap, iterators, [mapargs...]; 
    &lt;keyword arguments&gt;, [mapkwargs...])</code></pre><p>Evaluate a parallel mapreduce over the range spanned by  the outer product of the iterators, where the reduction operation is a sum.  The argument <code>iterators</code> must be a strictly-increasing range of integers,  or a tuple of such ranges. The map is evaluated elementwise  over the entire range of parameters.</p><p>Arguments <code>mapargs</code> and keyword arguments <code>mapkwargs</code> — if provided — are  passed on to the mapping function <code>fmap</code>.</p><pre><code class="language-none">pmapsum_elementwise(fmap, Tmap, iterators, [mapargs...]; 
    &lt;keyword arguments&gt;, [mapkwargs...])</code></pre><p>The type <code>Tmap</code> is the return type of the map.  The returned values will be coerced to  the specified type if possible, throwing an error otherwise.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>showprogress::Bool = false</code> : Displays a progress-bar if set to true</li><li><code>progressdesc = &quot;Progress in pmapreduce : &quot;</code> : Leading text in the progress-bar</li></ul><p>See also: <a href="#ParallelUtilities.pmapreduce_commutative_elementwise-Tuple{Function,Type,Function,Type,Any,Vararg{Any,N} where N}"><code>pmapreduce_commutative_elementwise</code></a>, <a href="#ParallelUtilities.pmapsum-Tuple{Function,Type,Any,Vararg{Any,N} where N}"><code>pmapsum</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/mapreduce.jl#LL463-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.procrange_recast-Tuple{ParallelUtilities.AbstractConstrainedProduct,Integer}" href="#ParallelUtilities.procrange_recast-Tuple{ParallelUtilities.AbstractConstrainedProduct,Integer}"><code>ParallelUtilities.procrange_recast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">procrange_recast(ps::AbstractConstrainedProduct, np_new::Integer)</code></pre><p>Return the range of processor ranks that would contain the values in <code>ps</code> if the  iterators used to construct <code>ps</code> were split across <code>np_new</code> processes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; iters = (1:10, 4:6, 1:4);

julia&gt; ps = ProductSplit(iters, 5, 2); # split across 5 processes initially

julia&gt; procrange_recast(ps, 10) # If `iters` were spread across 10 processes
3:4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL869-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.procrange_recast-Tuple{Tuple,ParallelUtilities.AbstractConstrainedProduct,Integer}" href="#ParallelUtilities.procrange_recast-Tuple{Tuple,ParallelUtilities.AbstractConstrainedProduct,Integer}"><code>ParallelUtilities.procrange_recast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">procrange_recast(iterators::Tuple, ps::ProductSplit, np_new::Integer)</code></pre><p>Return the range of processor ranks that would contain the values in <code>ps</code> if  the outer produce of the ranges in <code>iterators</code> is split across <code>np_new</code>  workers.</p><p>The values contained in <code>ps</code> should be a subsection of the outer product of  the ranges in <code>iterators</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; iters = (1:10, 4:6, 1:4);

julia&gt; ps = ProductSplit(iters, 5, 2);

julia&gt; procrange_recast(iters, ps, 10)
3:4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL825-L844">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.sumcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T" href="#ParallelUtilities.sumcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T"><code>ParallelUtilities.sumcat_aligned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sumcat_aligned(A::AbstractArray{T,N}...; dims) where {T,N}</code></pre><p>Concatenate the arrays along the dimensions <code>dims</code> according to their axes,  with overlapping sections being summed over. Returns an <code>OffsetArray</code> with the minimal  axis span encompassing all the arrays.</p><p><code>dims</code> may be an <code>Integer</code> or a collection of <code>Integer</code>s, but all elements of <code>dims</code> must be from the range <code>1:N</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ParallelUtilities.sumcat_aligned(ones(1:2), ones(4:5), dims=1)
5-element OffsetArray(::Array{Float64,1}, 1:5) with eltype Float64 with indices 1:5:
 1.0
 1.0
 0.0
 1.0
 1.0

julia&gt; ParallelUtilities.sumcat_aligned(ones(1:2, 1:2), ones(2:3, 2:3), dims=(1,2))
3×3 OffsetArray(::Array{Float64,2}, 1:3, 1:3) with eltype Float64 with indices 1:3×1:3:
 1.0  1.0  0.0
 1.0  2.0  1.0
 0.0  1.0  1.0

julia&gt; ParallelUtilities.sumcat_aligned(ones(1:2, 1:2), ones(3:4, 3:4), dims=(1,2))
4×4 OffsetArray(::Array{Float64,2}, 1:4, 1:4) with eltype Float64 with indices 1:4×1:4:
 1.0  1.0  0.0  0.0
 1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0
 0.0  0.0  1.0  1.0</code></pre><p>See also: <a href="#ParallelUtilities.sumhcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T"><code>sumhcat_aligned</code></a>, <a href="#ParallelUtilities.sumvcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T"><code>sumvcat_aligned</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/reductionfunctions.jl#LL31-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.sumhcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T" href="#ParallelUtilities.sumhcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T"><code>ParallelUtilities.sumhcat_aligned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sumhcat_aligned(A::AbstractArray{T,N}...) where {T,N}</code></pre><p>Concatenate the arrays along the second dimension according to their axes,  with overlapping sections being summed over. Returns an <code>OffsetArray</code> with the minimal  axis span encompassing all the arrays. </p><p>The input arrays must be at least two-dimensional.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ParallelUtilities.sumhcat_aligned(ones(2, 1:2), ones(2, 4:5))
2×5 OffsetArray(::Array{Float64,2}, 1:2, 1:5) with eltype Float64 with indices 1:2×1:5:
 1.0  1.0  0.0  1.0  1.0
 1.0  1.0  0.0  1.0  1.0

julia&gt; ParallelUtilities.sumhcat_aligned(ones(1:2, 1:2), ones(1:2, 2:3))
2×3 OffsetArray(::Array{Float64,2}, 1:2, 1:3) with eltype Float64 with indices 1:2×1:3:
 1.0  2.0  1.0
 1.0  2.0  1.0</code></pre><p>See also: <a href="#ParallelUtilities.sumcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T"><code>sumcat_aligned</code></a>, <a href="#ParallelUtilities.sumvcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T"><code>sumvcat_aligned</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/reductionfunctions.jl#LL149-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.sumvcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T" href="#ParallelUtilities.sumvcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T"><code>ParallelUtilities.sumvcat_aligned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sumvcat_aligned(A::AbstractArray{T,N}...) where {T,N}</code></pre><p>Concatenate the arrays along the first dimension according to their axes,  with overlapping sections being summed over. Returns an <code>OffsetArray</code> with the minimal  axis span encompassing all the arrays.</p><p>The input arrays must be at least one-dimensional.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ParallelUtilities.sumvcat_aligned(ones(1:2), ones(4:5))
5-element OffsetArray(::Array{Float64,1}, 1:5) with eltype Float64 with indices 1:5:
 1.0
 1.0
 0.0
 1.0
 1.0

julia&gt; ParallelUtilities.sumvcat_aligned(ones(1:2, 1:2), ones(2:3, 1:2))
3×2 OffsetArray(::Array{Float64,2}, 1:3, 1:2) with eltype Float64 with indices 1:3×1:2:
 1.0  1.0
 2.0  2.0
 1.0  1.0</code></pre><p>See also: <a href="#ParallelUtilities.sumcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T"><code>sumcat_aligned</code></a>, <a href="#ParallelUtilities.sumhcat_aligned-Union{Tuple{Vararg{AbstractArray{T,N},N1} where N1}, Tuple{N}, Tuple{T}} where N where T"><code>sumhcat_aligned</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/reductionfunctions.jl#LL92-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.whichproc-Tuple{Any,Any,Integer}" href="#ParallelUtilities.whichproc-Tuple{Any,Any,Integer}"><code>ParallelUtilities.whichproc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">whichproc(iterators::Tuple, val::Tuple, np::Integer)</code></pre><p>Return the processor rank that will contain <code>val</code> if the outer  product of the ranges contained in <code>iterators</code> is split evenly  across <code>np</code> processors.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; iters = (1:4, 2:3);

julia&gt; np = 2;

julia&gt; ProductSplit(iters, np, 2) |&gt; collect
4-element Array{Tuple{Int64,Int64},1}:
 (1, 3)
 (2, 3)
 (3, 3)
 (4, 3)

julia&gt; whichproc(iters, (2,3), np)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL761-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.whichproc_localindex-Tuple{Tuple,Tuple,Integer}" href="#ParallelUtilities.whichproc_localindex-Tuple{Tuple,Tuple,Integer}"><code>ParallelUtilities.whichproc_localindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">whichproc_localindex(iterators::Tuple, val::Tuple, np::Integer)</code></pre><p>Return <code>(rank,ind)</code>, where <code>rank</code> is the rank of the worker that <code>val</code> will reside on if the outer product  of the ranges in <code>iterators</code> is spread over <code>np</code> workers, and <code>ind</code> is the index of <code>val</code> in the local section on that worker.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; iters = (1:4, 2:8);

julia&gt; np = 10;

julia&gt; whichproc_localindex(iters, (2,4), np)
(4, 1)

julia&gt; ProductSplit(iters, np, 4) |&gt; collect
3-element Array{Tuple{Int64,Int64},1}:
 (2, 4)
 (3, 4)
 (4, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/productsplit.jl#LL926-L949">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.workersactive-Tuple{Tuple}" href="#ParallelUtilities.workersactive-Tuple{Tuple}"><code>ParallelUtilities.workersactive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">workersactive(iterators::Tuple)</code></pre><p>Workers required to split the outer product of the iterators.  If <code>prod(length, iterators) &lt; nworkers()</code> then the first <code>prod(length, iterators)</code> workers are chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/utils.jl#LL12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.ClusterQueryUtils.gethostnames" href="#ParallelUtilities.ClusterQueryUtils.gethostnames"><code>ParallelUtilities.ClusterQueryUtils.gethostnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gethostnames(procs = workers())</code></pre><p>Return the hostname of each worker in <code>procs</code>. This is obtained by evaluating  <code>Libc.gethostname()</code> on each worker asynchronously.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p><code>gethostnames</code> is deprecated in favor of <code>hostnames</code>    </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/clusterquery.jl#LL12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.ClusterQueryUtils.hostnames" href="#ParallelUtilities.ClusterQueryUtils.hostnames"><code>ParallelUtilities.ClusterQueryUtils.hostnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hostnames(procs = workers())</code></pre><p>Return the hostname of each worker in <code>procs</code>. This is obtained by evaluating  <code>Libc.gethostname()</code> on each worker asynchronously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/clusterquery.jl#LL23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.ClusterQueryUtils.nodenames" href="#ParallelUtilities.ClusterQueryUtils.nodenames"><code>ParallelUtilities.ClusterQueryUtils.nodenames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nodenames(procs = workers())</code></pre><p>Return the unique hostnames that the workers in <code>procs</code> lie on.  On an HPC system these are usually the hostnames of the nodes involved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/clusterquery.jl#LL42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.ClusterQueryUtils.nprocs_node" href="#ParallelUtilities.ClusterQueryUtils.nprocs_node"><code>ParallelUtilities.ClusterQueryUtils.nprocs_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nprocs_node(procs = workers())</code></pre><p>Return the number of workers on each host. On an HPC system this would return the number of workers on each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/clusterquery.jl#LL76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ParallelUtilities.ClusterQueryUtils.procs_node" href="#ParallelUtilities.ClusterQueryUtils.procs_node"><code>ParallelUtilities.ClusterQueryUtils.procs_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">procs_node(procs = workers())</code></pre><p>Return the worker ids on each host of the cluster. On an HPC system this would return the workers on each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jishnub/ParallelUtilities.jl/blob/6a906da18a551c7c8ab50ec3dfaa2abaffa69134/src/clusterquery.jl#LL57-L62">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 27 December 2020 09:14">Sunday 27 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
